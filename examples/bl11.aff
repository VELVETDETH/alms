(* Affine opaque objects (contract violation: blame "Double") *)

let[A] makePair : (int -> int) -> int -> (int -o int) * int =
  fun f: (int -> int) ->
    fun x: int ->
      (f, x)

let[A] doPair : (int -o int) * int -> int =
  fun pair: (int -o int) * int ->
    let (f, x) = pair in
    let result = f x in
      putStr "f(";
      putStr (string_of[int] x);
      putStr ") = ";
      putStrLn (string_of[int] result);
      result

module Double = struct[C]
  let double : int -> {(int -o int) * int} =
    fun z: int ->
      makePair (( * ) 2) z
end
(* returns an affine object, but doesn't break affinity itself. *)

in let pair = Double.double 4 in
     doPair pair;
     print[int] (doPair pair)
(* mis-uses the affine object returned by double *)
