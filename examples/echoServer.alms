(* Echo server written using state-tracked sockets. *)

#load "libsocketcap3"

module EchoServer = struct
  open SocketCap

  (* This is a bit different than the version in the paper, because
   * it uses exceptions. *)
  let handleClient sock f !cap =
    let rec loop () =
      let str = recv sock 1024 cap in
        send sock (f str) $> cap;
        loop ()
    in loop ()

  let rec acceptLoop sock f cap =
    let (clientsock, clientcap, cap) = accept sock cap in
      putStrLn "Opened connection";
      (Thread.fork :> (unit -A> unit) → Thread.thread)
        (λ _ → try handleClient clientsock f clientcap
               with SocketError _ → putStrLn "Closed connection");
      acceptLoop sock f cap

  let serve port f =
    let (sock, !cap) = socket () in
    bind sock port $> cap;
    listen sock $> cap;
    acceptLoop sock f cap
end

let serverFun (s: string) = s

let main = function
  | [port] → EchoServer.serve (int_of_string port) serverFun
  | _      → failwith "Usage: echoServer.aff PORT\n"

in main (getArgs ())
