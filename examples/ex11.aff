(* Affine opaque objects (contract violation: blame "*main*") *)

module[A] makePair : (int -> int) -> int -> (int -o int) * int =
  \f: int -> int.
    \x: int.
      (f, x)

module[A] doPair : (int -o int) * int -> int =
  \pair: (int -o int) * int.
    let (f, x) = pair in
    let result = f x in
      putStr "f(";
      putStr (string_of[int] x);
      putStr ") = ";
      putStrLn (string_of[int] result);
      result

module[C] double : int -> {(int -o int) * int} =
  \z: int.
    makePair (mul 2) z
(* returns an affine object, but doesn't break affinity itself. *)

in let pair = double 4 in
     doPair pair;
     print[int] (doPair pair)
(* mis-uses the affine object returned by double *)
