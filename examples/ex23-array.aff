(* Demonstrates libraries in both directions. Correct *)

(*
    This program is like ex21-array.aff, except that the main
    algorithm is written in C, which means that it uses contract
    checks on the array capabilities rather than static checks.
*)

abstype[C] 'a array = Array of (int -> 'a) ref with
  let[C] newArray['a] (default: 'a): 'a array =
    Array (ref (fun ix: int -> default))

  let[C] at['a] (Array r: 'a array) (ix: int): 'a = !r ix

  let[C] update['a] (Array r: 'a array) (ix: int) (new: 'a): unit =
    let oldf = !r in
      (r <- fun ix': int -> if ix == ix' then new else oldf ix');
      ()
end

abstype[A] ('a, 't) array = AfArray of {{'a} array} with
  abstype[A] ('t, 'c) readcap qualifier A = MkCap with
    type[A] 't writecap = ('t, unit) readcap

    let[A] withNewArray['a] (default: 'a)
                       ['r] (kont: all 't.
                                     ('a, 't) array -o
                                     't writecap -o
                                     'r): 'r =
      kont[unit] (AfArray['a,unit] (newArray default)) MkCap[unit,unit]

    let[A] split['t,'c] (_: ('t, 'c) readcap)
               : ('t, 'c * unit) readcap * ('t, 'c * unit) readcap
             = (MkCap['t, 'c * unit], MkCap['t, 'c * unit])

    let[A] join['t,'c]
               (_: ('t, 'c * unit) readcap * ('t, 'c * unit) readcap)
               : ('t, 'c) readcap
             = MkCap['t, 'c]
  end

  type[A] 't writecap = ('t, unit) readcap

  let[A] read['a,'t] (AfArray arr: ('a, 't) array) (ix: int)
             ['c] (cap : ('t, 'c) readcap) : 'a * ('t, 'c) readcap =
           (at arr ix, cap)

  let[A] write['a,'t] (AfArray arr: ('a, 't) array) (ix: int) (new: 'a)
                      (cap : 't writecap) : 't writecap =
           update arr ix new;
           cap
end

type[C] range = int * int

let[C] iter ((start, limit): range)
            ['acc] (f: int -> 'acc -> 'acc) (z: 'acc) =
  let rec loop (i: int) (acc: 'acc): 'acc =
    if i < limit
      then loop (i + 1) (f i acc)
      else acc
   in loop 0 z

type[C] ('a, 't) afarray = {({'a}, {'t}) array}
type[C] ('t, 'c) readcap = {({'t}, {'c}) readcap}
type[C] 't writecap      = {({'t}) writecap}

let[C] copyFromTo (range: range)
                  ['a,'tsrc,'tdst,'csrc]
                  (src: ('a, 'tsrc) afarray)
                  (dst: ('a, 'tdst) afarray) =
  iter range
    (fun (i: int)
         ((capsrc, capdst): ('tsrc, 'csrc) readcap * 'tdst writecap) ->
      let (elt, capsrc) = read src i capsrc in
      let capdst        = write dst i elt capdst in
        (capsrc, capdst))

let[C] crazy['a]
  (default: 'a)
  (range: range)
  (depth: int)
  (leaf: all 't. ('a, 't) afarray -> 't writecap -> 't writecap)
  (branch: all 't 's 'r 'c 'd.
             ('a, 't) afarray -> ('a, 's) afarray -> ('a, 'r) afarray ->
             't writecap * ('s, 'c) readcap * ('r, 'd) readcap ->
             't writecap * ('s, 'c) readcap * ('r, 'd) readcap) =
  let rec loop (i: int)
               ['t] (start: ('a, 't) afarray) (cap: 't writecap)
               : 't writecap =
    if i == 0
      then cap
      else
        withNewArray default
         (fun 's (lft: ('a, 's) afarray) (caplft: 's writecap) ->
           withNewArray default
            (fun 'r (rgt: ('a, 'r) afarray) (caprgt: 'r writecap) ->
               let (cap1, cap2) = split cap in
               let fl = newFuture (fun _:unit ->
                          let (cap1, caplft) =
                                copyFromTo range start lft (cap1, caplft)
                           in (cap1, loop (i - 1) lft caplft)) in
               let fr = newFuture (fun _:unit ->
                          let (cap2, caprgt) =
                                 copyFromTo range start rgt (cap2, caprgt)
                           in (cap2, loop (i - 1) rgt caprgt)) in
               let (cap1, caplft) = getFuture fl in
               let (cap2, caprgt) = getFuture fr in
               let cap            = join (cap1, cap2) in
               let (cap, _, _)    = branch start lft rgt
                                           (cap, caplft, caprgt)
                in cap))
   in loop depth

let[C] main (width: int) (depth: int) : unit =
  let range = (0, width) in
  let fill['t] (a: (int, 't) afarray) =
    iter range (fun (i: int) -> write a i i) in
  let print_array['a,'t] (a: ('a, 't) afarray)
                 ['c] (cap: ('t, 'c) readcap) =
    putStr "[";
    let (_, cap) =
      iter range
        (fun (i: int) ((first, cap): bool * ('t, 'c) readcap) ->
          (if first then () else putStr ",");
          let (elt, cap) = read a i cap in
            putStr (string_of elt);
            (false, cap))
        (true, cap) in
    putStrLn "]";
    cap in
  let leaf['t] (a: (int, 't) afarray) (cap: 't writecap) = cap in
  let branch ['t,'s,'r,'c,'d]
             (out: (int, 't) afarray)
             (lft: (int, 's) afarray)
             (rgt: (int, 'r) afarray) =
    iter range
      (fun (i: int)
           ((capout, caplft, caprgt)
              : 't writecap * ('s, 'c) readcap * ('r, 'd) readcap) ->
        let (elt1, caplft) = read lft i caplft in
        let (elt2, caprgt) = read rgt (i + 1) caprgt in
        let capout = write out i (elt1 + elt2) capout in
          (capout, caplft, caprgt)) in
    withNewArray 0
      (fun 't (a: (int, 't) afarray) (cap: 't writecap) ->
         let cap = fill a cap in
         let cap = crazy 0 range depth leaf branch a cap in
           print_array a cap;
           ())

 in
   main 10 4
