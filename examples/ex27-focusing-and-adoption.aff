(* Demonstrates Pottier's (2007) version of adoption/focus
   (Faehnrich and DeLine, 2002). *)

(* Some affine list operations. *)

(*
  type variables:
    '<a                 stored value
    '<r                 result of continuation/callback
    't                  region name

  variables:
    x, y: '<a           stored value
    xs: '<a list        region representation

  T[[ { p |-> t } ]]     = (p, T[[ t ]]) region1
  T[[ { p |->^w t } ]]   = (p, T[[ t ]]) region
  T[[ Ptr t ]]           = T[[ t ]] ptr
  T[[ exist 't. t ]]     = all '<r. (all 't. t -o '<r) -o '<r

*)

let[A] length['<a] (xs: '<a list) : int * '<a list =
  foldrA (fun (x: '<a) (n: int, xs: '<a list) ->
            (n + 1, Cons (x, xs)))
         (0, Nil['<a]) xs

let[A] snoc['<a] (x: '<a) | (xs: '<a list) : '<a list =
  foldrA (fun (x: '<a) (xs: '<a list) -> Cons (x, xs))
         (Cons (x, Nil['<a])) xs

let[A] revAppN =
  let rec loop['<a] (n: int) (xs: '<a list) | (acc: '<a list)
                    : '<a list * '<a list =
        match n with
        | 0 -> (acc, xs)
        | _ -> match xs with
               | Cons(x, xs) -> loop (n - 1) xs (Cons (x, acc))
               | xs          -> (acc, xs)
  in loop

let[A] rev['<a] (xs: '<a list) : '<a list =
  let (_, acc) = revAppN (-1) xs Nil['<a] 
   in acc

let[A] swapN['<a] (ix: int) (y: '<a) | (xs: '<a list)
       : '<a * '<a list =
  let (Cons(x, xs), acc) = revAppN ix xs Nil['<a] in
  let (xs, _) = revAppN (-1) acc (Cons (y, xs)) in
    (x, xs)

abstype[A] ('t, '<a) region qualifier A = Rgn of '<a list with
  abstype[A] ('t, '<a) region1 qualifier A = Rgn1 of '<a with
    abstype[A] 't ptr qualifier U = Ptr of int with
      let[A] newRgn['<a,'<r] (k: all 't. ('t, '<a) region -o '<r) : '<r =
        k (Rgn[unit] (Nil['<a]))
      let[A] freeRgn['<a,'t] (rgn: ('t, '<a) region) = ()

      let[A] mallocIn['<a,'t] (Rgn xs: ('t, '<a) region) | (a: '<a)
             : 't ptr * ('t, '<a) region =
        let (ix, xs) = length xs in
          (Ptr['t] ix, Rgn['t] (snoc a xs))
      let[A] swap['<a,'t] (Rgn xs: ('t, '<a) region) |
                          (Ptr ix: 't ptr) (x: '<a)
                          : '<a * ('t, '<a) region =
        let (y, xs) = swapN ix x xs in
          (y, Rgn['t] xs)

      let[A] malloc['<r] (k: all 't. ('t, unit) region1 -o 't ptr -o '<r)
                          : '<r =
        k (Rgn1[unit] ()) (Ptr[unit] 0)
      let[A] swap1['<a,'<b,'t] (Rgn1 x: ('t, '<a) region1) |
                               (_: 't ptr) (y: '<b)
                               : '<a * ('t, '<b) region1 =
        (x, Rgn1['t] y)

      let[A] adopt['<a,'t1,'t2] (rgn: ('t1, '<a) region) |
                                (Rgn1 x: ('t2, '<a) region1)
                                (_: 't2 ptr)
                                : 't1 ptr * ('t1, '<a) region =
        mallocIn rgn x

      let[A] focus['<a,'t,'<r]
               (Rgn xs: ('t, '<a) region) |
               (Ptr ix: 't ptr)
               (k: all 't1. ('t1, '<a) region1 -o
                            't1 ptr -o
                            (('t1, '<a) region1 -o ('t, '<a) region) -o
                            '<r)
               : '<r =
         let (Cons (x, xs), acc) = revAppN ix xs Nil['<a] in
           k (Rgn1[unit] x) (Ptr[unit] 0)
             (fun (Rgn1 y: (unit, '<a) region1) ->
                let (xs, _) = revAppN (-1) acc (Cons (y, xs)) in
                  Rgn['t] xs)

      let[A] packRgn['<a,'t] (rgn: ('t, '<a) region) |
                    ['<r]    (k: all 't. ('t, '<a) region -o '<r) : '<r =
        k rgn
      let[A] packPtr['<a,'t] (rgn: ('t, '<a) region1) |
                             (ptr: 't ptr)
                       ['<r] (k: all 't. ('t, '<a) region1 -o 't ptr -o '<r)
                             : '<r =
        k rgn ptr
      let[A] packPtrs['<a,'t] (rgn: ('t, '<a) region1) |
                              (ptrs: 't ptr list)
                        ['<r] (k: all 't. ('t, '<a) region1 -o
                                          't ptr list -o '<r)
                              : '<r =
        k rgn ptrs
    end
  end
end
