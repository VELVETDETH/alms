#load "libsessiontype.aff"

open SessionType

let rec[C] take['a] (z: int) (xs: 'a list) : 'a list =
  if z < 1
    then Nil['a]
    else match xs with
         | Cons(x, xs') -> Cons['a](x, take (z - 1) xs')
         | _            -> Nil['a]

let rec[C] drop['a] (z: int) (xs: 'a list) : 'a list =
  if z < 1
    then xs
    else match xs with
         | Cons(_, xs') -> drop (z - 1) xs'
         | _            -> Nil['a]

let[C] sublist['a] (start: int) (stop: int) (xs: 'a list) =
  take (stop - start) (drop start xs)

let[C] substring (start: int) (stop: int) (s: string) =
  implode (sublist start stop (explode s))

type[A] prot = string send; int send; string recv; unit

let[A] client (r: prot rendezvous) (s: string) (z: int) =
    let c      = request r in
    let c      = send c s  in
    let c      = send c z  in
    let (s, _) = recv c in
      putStrLn s

let[A] startServer (s: string,
                    c: (int recv; string send; unit) channel) =
  let (z, c) = recv c in
  let _      = send c (substring 0 z s) in
    ()

let interface fork' :> (unit -o unit) -> {Thread.thread} = Thread.fork

let[A] listen (r: prot rendezvous) =
  let c = accept r in
    fork' (fun () -> startServer (recv c))

let[A] main (s: string) (z: int) =
  let r = newRendezvous[prot] () in
  let f = Future.new (fun () -> client r s z) in
  listen r;
  Future.get f

in
  main "Hello, world!" 5
