#load "libarray"

module A = Array

type currency = int
let (+$) (a: currency) (b: currency) = a + b

module Example = struct
  let deposit (a: currency A.array) (acct: int) (amount: currency) =
    A.put a acct (A.get a acct +$ amount)
end

module type LOCK = sig
  type lock
  val new  : unit -> lock
  val acquire : lock -> unit
  val release : lock -> unit
end

module Lock : LOCK = struct
  type lock = unit MVar.mvar
  let new = MVar.new
  let acquire (mv: lock) = MVar.take mv
  let release (mv: lock) = MVar.put mv ()
end

module LockExample = struct
  let deposit (a: currency A.array) (acct: int) (amount: currency)
              (lock: Lock.lock) =
    Lock.acquire lock;
    A.put a acct (A.get a acct +$ amount);
    Lock.release lock

  let deposit (a: currency A.array) (acct: int) (amount: currency)
              (lock: Lock.lock) =
    Lock.acquire lock;
    A.put a acct (A.get a acct +$ amount);
    Lock.acquire lock
end

module type LOCK_CAP = sig
  type 't lock
  type 't locked qualifier A
  val new     : unit -> ex 't. 't lock
  val acquire : 't lock -> 't locked
  val release : 't lock -> 't locked -> unit
end

module LockCap : LOCK_CAP = struct
  type 't lock   = Lock.lock
  type 't locked = unit
  let new = Lock.new
  let acquire = Lock.acquire
  let release (lock: Lock.lock) _ = Lock.release lock
end

module LockCapExample = struct
  let deposit (a: currency A.array) (acct: int) (amount: currency)
              (lock: 't LockCap.lock) =
    let cap = LockCap.acquire lock in
    A.put a acct (A.get a acct +$ amount);
    LockCap.release lock cap

  let deposit (a: currency A.array) (acct: int) (amount: currency)
              (lock: 't LockCap.lock) =
    let cap = LockCap.acquire lock in
    LockCap.release lock cap;
    A.put a acct (A.get a acct +$ amount)
end

module type SINGLE_STATIC = sig
  type 'a array qualifier A

  val build : int -> (int -> 'a) -> 'a array
  val get   : 'a array -> int -> 'a * 'a array
  val put   : 'a array -> int -> 'a -> 'a array
end

module SingleStatic : SINGLE_STATIC = struct
  type 'a array = 'a A.array

  let build = A.build

  let get (ar: 'a array) (ix: int) =
    (A.get ar ix, ar)

  let put (ar: 'a array) (ix: int) (new: 'a) =
    A.put ar ix new;
    ar
end

module SingleStaticExample = struct
  let deposit (a: currency SingleStatic.array)
              (acct: int) (amount: currency) =
    let (balance, a') = SingleStatic.get a acct in
      SingleStatic.put a' (balance + amount)
end

module type ARRAY_CAP = sig
  type ('a, 't) array
  type 't arraycap

  val build : int -> (int -> 'a) ->
                ex 't. ('a, 't) array * 't arraycap
  val get   : ('a, 't) array -> int ->
                't arraycap -> 'a * 't arraycap
  val put   : ('a, 't) array -> int -> 'a ->
                't arraycap -> 't arraycap
end

module ArrayCap : ARRAY_CAP = struct
  type ('a, 't) array = 'a A.array
  type 't arraycap    = unit

  let build (size: int) (builder: int -> 'a) =
    (A.build size builder, ())

  let get (ar: ('a, 't) array) (ix: int) _ =
    (A.get ar ix, ())

  let put (ar: ('a, 't) array) (ix: int) (new: 'a) _ =
    A.put ar ix new
end

module ArrayCapExample = struct
  let deposit (a: (currency, 't) ArrayCap.array)
              (acct: int) (amount: currency)
              (cap: 't ArrayCap.arraycap) =
    let (balance, cap) = ArrayCap.get a acct cap in
      ArrayCap.put a acct (balance +$ amount) cap
end

module type ARRAY_CAP_LOCK = sig
  include ARRAY_CAP
  type 't arraylock

  val new : 't arraycap -> 't arraylock
  val acquire : 't arraylock -> 't arraycap
  val release : 't arraylock -> 't arraycap -> unit
end

module ArrayCapLock : ARRAY_CAP_LOCK = struct
  open ArrayCap
  type 't arraylock   = 't arraycap MVar.mvar

  let new (cap: 't arraycap) = MVar.new cap
  let acquire = MVar.take
  let release = MVar.put
end

module ArrayCapLockExample = struct
  let deposit (a: (currency, 't) ArrayCapLock.array)
              (acct: int) (amount: currency)
              (lock: 't ArrayCapLock.arraylock) =
    let cap = ArrayCapLock.acquire lock in
    let (balance, cap) = ArrayCapLock.get a acct cap in
    let cap = ArrayCapLock.put a acct (balance +$ amount) cap in
      ArrayCapLock.release lock cap
end

module type FRACTIONAL = sig
  type 1
  type 2
  type 'n / 'd
  type ('c,'t) cap qualifier A
  type ('a,'t) array

  val build : int -> (int -> 'a) ->
                ex 't. ('a,'t) array * (1,'t) cap
  val get   : ('a,'t) array -> int ->
                ('c,'t) cap -> 'a * ('c,'t) cap
  val put   : ('a,'t) array -> int -> 'a ->
                (1,'t) cap -> (1,'t) cap

  val split : ('c,'t) cap -> ('c/2,'t) cap * ('c/2,'t) cap
  val join  : ('c/2,'t) cap * ('c/2,'t) cap -> ('c,'t) cap
end

module Fractional : FRACTIONAL = struct
  type 1
  type 2
  type 'n / 'd
  type ('c,'t) cap = unit

  type ('a,'t) array = 'a A.array

  let build['a] (size: int) (builder: int -> 'a) =
    (A.build size builder, ())

  let get (ar: 'a A.array) (ix: int) _ = (A.get ar ix, ())
  let put (ar: 'a A.array) (ix: int) (new: 'a) _ =
    A.put ar ix new

  let split _ = ((), ())
  let join  _ = ()
end

module type RW_LOCK = sig
  type ('a, 't) array
  type read
  type write
  type ('t, 'm) arraycap qualifier A

  val build : int -> (int -> 'a) -> ex 't. ('a, 't) array

  val acquireR : ('a, 't) array -> ('t, read) arraycap
  val acquireW : ('a, 't) array -> ('t, write) arraycap
  val release  : ('a, 't) array -> ('t, 'm) arraycap -> unit

  val get : ('a, 't) array -> int ->
              ('t, 'm) arraycap -> 'a * ('t, 'm) arraycap
  val put : ('a, 't) array -> int -> 'a ->
              ('t, write) arraycap -> ('t, write) arraycap
end

#load "libqueue"

module RWLock : RW_LOCK = struct
  type queue = (unit MVar.mvar + unit MVar.mvar) Queue.queue
  type lock  = (queue * int) MVar.mvar
  type ('a,'t) array = 'a A.array * lock
  type read
  type write
  type ('t,'m) arraycap = unit

  let build (size: int) (builder: int -> 'a) =
    (A.build size builder, MVar.new ((Queue.empty : queue), 0))

  let show (who: string) ((q, count): queue * int) = ()
    (*
    ;
    putStr ("[" ^ who ^ "] count: " ^ string_of_int count ^ " ");
    let rec loop (q: queue) : unit =
      match Queue.dequeueA q with
      | None -> putStr "\n"
      | Some (Left _, q)  -> putStr "R"; loop q
      | Some (Right _, q) -> putStr "W"; loop q
    in loop q;
    *)

  let showL (who: string) (lock: lock) =
    let (q, count) = MVar.take lock in
      show who (q, count);
      MVar.put lock (q, count)

  let wake (lock: lock) =
    showL "wake" lock;
    let rec wakeReaders (q: queue) (count: int) : unit = 
      show "wakeReaders" (q, count);
      match Queue.dequeueA q with
      | Some (Left reader, q) ->
          MVar.put reader ();
          wakeReaders q (count + 1)
      | _ -> MVar.put lock (q, count); show "endWR" (q, count) in
    match MVar.take lock with
    | (q, -1)    -> MVar.put lock (q, -1)
    | (q, 0)     -> (match Queue.dequeueA q with
                     | None -> MVar.put lock (q, 0)
                     | Some (Right writer, q) ->
                         MVar.put writer ();
                         MVar.put lock (q, -1)
                     | _ -> wakeReaders q 0)
    | (q, count) -> wakeReaders q count

  let acquireR ((rep, lock) : ('a,'t) array) =
    let (q, count) = MVar.take lock in
    show "acquireR" (q, count);
    let wait = MVar.newEmpty[unit] () in
      MVar.put lock (Queue.enqueue (Left wait) q, count);
      wake lock;
      MVar.take wait

  let acquireW ((rep, lock) : ('a,'t) array) =
    let (q, count) = MVar.take lock in
    show "acquireW" (q, count);
    let wait = MVar.newEmpty[unit] () in
      MVar.put lock (Queue.enqueue (Right wait) q, count);
      wake lock;
      MVar.take wait

  let release ((rep, lock) : ('a,'t) array) _ =
    let (q, count) = MVar.take lock in
      show "release" (q, count);
      let count' = if count > 1 then count - 1 else 0 in
      MVar.put lock (q, count');
      wake lock

  let get ((rep, _) : ('a,'t) array) (ix: int) () =
    (A.get rep ix, ())
  let put ((rep, _) : ('a,'t) array) (ix: int) (new: 'a) () =
    A.put rep ix new
end

module RWLockTest = struct
  open RWLock

  let makeCounter () =
    let counter = MVar.new 0 in
      fun () ->
        let count = MVar.take counter in
          MVar.put counter (count + 1);
          count

  let delay () = Thread.delay 250000

  let reader (me: int) (a: (int,'t) array) =
    Future.new
      (fun () ->
        putStrLn ("reader " ^ string_of_int me ^ ": waiting");
        let cap = acquireR a in
        putStrLn ("reader " ^ string_of_int me ^ ": acquired");
        let (n, cap) = get a 0 cap in
        delay ();
        let (m, cap) = get a 0 cap in
        putStrLn ("reader " ^ string_of_int me ^ ": releasing");
        release a cap;
        if n != m
          then failwith "reader: meh"
          else ())

  let writer (me: int) (a: (int,'t) array) =
    Future.new
      (fun () ->
        putStrLn ("writer " ^ string_of_int me ^ ": waiting");
        let cap = acquireW a in
        putStrLn ("writer " ^ string_of_int me ^ ": acquired");
        let cap = put a 0 me cap in
        delay ();
        let (me', cap) = get a 0 cap in
        putStrLn ("writer " ^ string_of_int me ^ ": releasing");
        release a cap;
        if me != me'
          then failwith "writer: meh"
          else ())

  let go (iters: int) =
    let next       = makeCounter () in
    let Pack('t,a) = build 10 (fun x:int -> x) in
    let rec start (n: int) : unit Future.future list =
      if n < 1
        then Nil[any]
        else Cons (if random_int () % 8 == 0
                     then writer (next ()) a
                     else reader (next ()) a,
                   start (n - 1)) in
    let rec stop (fs: unit Future.future list) : unit =
      match fs with
      | Nil         -> ()
      | Cons(f, fs) -> Future.get f; stop fs in
    stop (start iters)
end
