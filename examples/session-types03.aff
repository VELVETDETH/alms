(* An example with session types, including recursion.
   Reads natural numbers (very brittle) from standard input
   until getting a blank line, then prints the sum. *)

type[A] protocol =
  mu 'r.
    ((int recv -> unit) *
     (int send -> 'r)) select

let[C] foldl =
  let rec loop 'a 'b (f : 'a -> 'b -> 'b) (z : 'b) (alst : 'a list) : 'b =
    match alst with
    | Nil          -> z
    | Cons(a,alst) -> loop f (f a z) alst
  in loop

-- This is pretty brittle :-)
let[C] stringToInt =
  fun s : string ->
    let each (digit : int) (acc : int) =
      let digit = digit - 48 in
      if digit <= -1
        then failwith[int] "digit out of range"
        else if 11 <= digit
          then failwith[int] "digit out of range"
          else digit + 10 * acc
    in foldl each 0 (explode s)

let[A] server =
  let rec loop (acc : int)
               (c   : protocol dual channel)
               : unit =
      match follow c with
      | Left c ->
          send c acc;
          ()
      | Right c ->
          let (x, c) = recv c in
            loop (acc + x) c
   in loop 0

let[A] client =
  let rec loop (c : protocol channel) : int =
    let s = getLine () in
      if s == ""
                then
                    let c      = sel1 c in
          let (r, _) = recv c in
            r
        else
          let c      = sel2 c in
          let c      = send c (stringToInt s) in
            loop c
   in loop

let[A] main =
  fun _ : unit ->
    let rv = newRendezvous[protocol] () in
      threadFork (fun _:unit -> server (accept rv));
      client (request rv)

in print (main ())

