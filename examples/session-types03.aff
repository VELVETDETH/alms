(* An example with session types, including recursion.
   Reads natural numbers (very brittle) from standard input
   until getting a blank line, then prints the sum. *)

module[C] foldl =
  let rec loop 'a 'b (f : 'a -> 'b -> 'b) (z : 'b) (as : 'a list) : 'b =
    match listcase as with
    | Left _  -> z
    | Right p -> let (a, as) = p in
                   loop f (f a z) as
  in loop

-- This is pretty brittle :-)
module[C] stringToInt =
  \s : string.
    let each (digit : int) (acc : int) =
      let digit = sub digit 48 in
      if le digit -1
        then failwith[int] "digit out of range"
        else if le 11 digit
          then failwith[int] "digit out of range"
          else add digit (mul 10 acc)
    in foldl each 0 (explode s)

module[A] server =
  let rec loop (acc : int)
               (c   : (mu 'r.
                         ((int send -> unit) *
                           (int recv -> 'r)) follow) channel)
               : unit =
      let c = unroll c in
        match follow c with
        | Left c ->
            send c acc;
            ()
        | Right c ->
            let (x, c) = recv c in
              loop (add acc x) c
   in loop 0

module[A] client =
  let rec loop (c : (mu 'r.
                      ((int recv -> unit) *
                       (int send -> 'r)) select) channel) : int =
    let c = unroll c in
    let s = getLine () in
      if eq s ""
        then
          let c      = sel1 c in
          let (r, _) = recv c in
            r
        else
          let c      = sel2 c in
          let c      = send c (stringToInt s) in
            loop c
   in loop

module[A] main =
  \_ : unit.
    let rv = newRendezvous[
               mu 'r.
                 ((int recv -> unit) *
                  (int send -> 'r)) select
             ] () in
      threadFork (\_:unit. server (accept rv));
      client (request rv)

in print (main ())

