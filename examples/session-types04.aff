-- Sutherland-Hodgman (1974) re-entrant polygon clipping

-- Some basic, low-level stuff
module[C] putAny = \'a (x: 'a). putStr (string_of x)

--
-- We first build a 3-D geometry library in sublanguage C:
--

-- Points and planes in R^3.
type[C] point = Point of float * float * float
type[C] plane = Plane of float * float * float * float

-- We use the plane Plane(a, b, c, d) to represent the open semi-space
-- { Point(x, y, z) | ax + by + cz + d > 0 }

module[C] putPoint =
  \Point(x, y, z): point.
    putStr "("; putAny x; putStr ", ";
    putAny y; putStr ", "; putAny z; putStr ")"

module[C] putPlane =
  \Plane(a, b, c, d): plane.
    putAny a; putStr "x + ";
    putAny b; putStr "y + ";
    putAny c; putStr "z + ";
    putAny d; putStr " = 0"

module[C] revC : all 'a. 'a list -> 'a list =
  \'a.
    let rec rev_acc (acc: 'a list) (xs: 'a list) : 'a list =
              match xs with
              | Nil         -> acc
              | Cons(x,xs') -> rev_acc (Cons(x,acc)) xs'
     in rev_acc Nil['a]

module[A] revA : all '<a. '<a list -> '<a list =
  \'<a (xs: '<a list).
    let rec rev_acc (acc: '<a list)| (xs: '<a list) : '<a list =
              match xs with
              | Nil         -> acc
              | Cons(x,xs') -> rev_acc (Cons(x,acc)) xs'
     in rev_acc Nil['<a] xs

module[C] splitWhile : all 'a. ('a -> bool) -> 'a list -> 'a list * 'a list
  = \'a (pred: 'a -> bool).
      let rec loop (acc: 'a list) (xs: 'a list) : 'a list * 'a list =
                match xs with
                | Nil         -> (revC acc, Nil['a])
                | Cons(x,xs') -> if pred x
                                   then loop (Cons(x,acc)) xs'
                                   else (revC acc, xs)
       in loop Nil['a]

module[C] not : bool -> bool =
  \b: bool. if b then false else true

module[C] notp : all 'a. ('a -> bool) -> ('a -> bool) =
  \'a (pred: 'a -> bool) (a: 'a). not (pred a)

module[C] isSpace : int -> bool =
  \c: int. match c with
           | ' '  -> true
           | '\t' -> true
           | '\n' -> true
           | '\r' -> true
           | _    -> false

module[C] dropSpace : int list -> int list =
  \cs: int list. let (_, result) = splitWhile isSpace cs in result

module[C] parsePoint : string -> point =
  let foil = \x: int list. float_of_string (implode x) in
  \s: string.
    let cs = explode s in
    let Cons('(', cs) = dropSpace cs in
    let (x, Cons(_,cs)) = splitWhile (notp (eq ',')) (dropSpace cs) in
    let (y, Cons(_,cs)) = splitWhile (notp (eq ',')) (dropSpace cs) in
    let (z, Cons(_,cs)) = splitWhile (notp (eq ')')) (dropSpace cs) in
      Point (foil x, foil y, foil z)

module[C] parsePlane : string -> plane =
  let foil = \x: int list. float_of_string (implode x) in
  \s: string.
    let cs = explode s in
    let (a, Cons(_,cs)) = splitWhile (notp (eq 'x')) (dropSpace cs) in
    let Cons('+',cs)    = dropSpace cs in
    let (b, Cons(_,cs)) = splitWhile (notp (eq 'y')) (dropSpace cs) in
    let Cons('+',cs)    = dropSpace cs in
    let (c, Cons(_,cs)) = splitWhile (notp (eq 'z')) (dropSpace cs) in
    let Cons('+',cs)    = dropSpace cs in
    let (d, Cons(_,cs)) = splitWhile (notp (eq '=')) (dropSpace cs) in
    let Cons('0',cs)    = dropSpace cs in
      Plane (foil a, foil b, foil c, foil d)

-- Is the point above the plane?  (i.e., in the semi-space)
module[C] isPointAbovePlane : point -> plane -> bool =
  \(Point(x, y, z): point)
   (Plane(a, b, c, d): plane).
     if lef (addf (mulf a x)
                  (addf (mulf b y)
                        (addf (mulf c z)
                              d)))
           (float_of_string "0")
       then false
       else true

-- Does the line segment between the two points intersect the plane,
-- and if so, where?
module[C] intersect : point -> point -> plane -> point option =
  \(Point(x1, y1, z1) as p1 : point)
   (Point(x2, y2, z2) as p2 : point)
   (Plane(a, b, c, d) as plane : plane).
     if eq (isPointAbovePlane p1 plane)
           (isPointAbovePlane p2 plane)
       then None[point]
       else let t = divf (addf (mulf a x1)
                               (addf (mulf b y1)
                                     (addf (mulf c z1)
                                           d)))
                         (addf (mulf a (subf x1 x2))
                               (addf (mulf b (subf y1 y2))
                                     (mulf c (subf z1 z2)))) in
            let x = addf x1 (mulf (subf x2 x1) t) in
            let y = addf y1 (mulf (subf y2 y1) t) in
            let z = addf z1 (mulf (subf z2 z1) t) in
              Some (Point (x, y, z))

--
-- When we implement the algorithm in A, we will treat points
-- and planes as opaque objects, so there's no need to marshal them,
-- but we do need to marshal options for the result of [C]intersect.
-- The standard way to do this is to write an elimination function
-- in the "from" sublanguage and then call the elimination function
-- with "to" constructors in the "to" sublanguage:
--

module[C] maybeC : all 'a 'r. ('a -> 'r) -> 'r -> 'a option -> 'r =
  \'a 'r (some: 'a -> 'r) (none: 'r) (opt: 'a option).
    match opt with
    | Some a -> some a
    | None   -> none

module[A] copt2aopt : all 'a. {{'a} option} -> 'a option =
  \'a. maybeC Some['a] None['a]

--
-- In sublanguage A, our protocol is to send an unbounded
-- sequence of points:
--

type[A] 'a sendList = mu 'x. (unit * ('a send -> 'x)) select

--
-- Each transducer takes a plane to clip by, and two rendezvous objects,
-- the first on which it expects to receive points, and the second on
-- which it will send points.
--

module[A] clipper : {plane} ->
                    {point} sendList dual channel ->
                    {point} sendList channel -o
                    unit =
    \(plane: {plane})
     (ic: {point} sendList dual channel)
     (oc: {point} sendList channel).
       let finish (oc: {point} sendList channel) =
             sel1 oc; () in
       let put (oc: {point} sendList channel) (pt: {point}) =
             send (sel2 oc) pt in
       let putCross (oc: {point} sendList channel)
                    (p1: {point}) (p2: {point}) =
             match copt2aopt[{point}] (intersect p1 p2 plane) with
             | Some pt -> put oc pt
             | None    -> oc in
       let putVisible (oc: {point} sendList channel)
                      (pt: {point}) =
             if isPointAbovePlane pt plane
               then put oc pt
               else oc in
         match follow ic with
         | Left _   -> finish oc
         | Right ic ->
             let (pt0, ic) = recv ic in
             let rec loop (ic: {point} sendList dual channel)|
                          (oc: {point} sendList channel)
                          (pt: {point}) : unit =
                       let oc = putVisible oc pt in
                         match follow ic with
                         | Left _   -> let oc = putCross oc pt pt0 in
                                         finish oc
                         | Right ic -> let (pt', ic) = recv ic in
                                       let oc = putCross oc pt pt' in
                                         loop ic oc pt'
               in loop ic oc pt0

module[A] printer : {point} sendList dual channel -> unit =
  let rec loop (ic: {point} sendList dual channel): unit =
            match follow ic with
            | Left _   -> ()
            | Right ic -> let (pt, ic) = recv ic in
                            putPoint pt;
                            putStr "\n";
                            loop ic
   in loop

-- The main protocol for the program, which lets us split our parser
-- from our main loop.
type[A] main_prot = mu 'x. ({point} sendList * ({plane} send -> 'x)) select

module[A] parser : main_prot channel -> unit =
  let rec plane_loop (oc: main_prot channel): unit =
            match getLine () with
            | "" -> point_loop (sel1 oc)
            | s  -> let plane = parsePlane s in
                    let oc    = send (sel2 oc) plane in
                      plane_loop oc
      and point_loop (oc: {point} sendList channel): unit =
            match getLine () with
            | "" -> sel1 oc; ()
            | s  -> let point = parsePoint s in
                    let oc    = send (sel2 oc) point in
                      point_loop oc
   in plane_loop

module[A] main =
  let rec get_planes (acc: {plane} list) (ic: main_prot dual channel)
                     : {plane} list * {point} sendList dual channel =
            match follow ic with
            | Left ic  -> (revA acc, ic)
            | Right ic -> let (plane, ic) = recv ic in
                            get_planes (Cons(plane,acc)) ic in
  let rec connect (planes: {plane} list)
                  (ic: {point} sendList dual channel)
                  : {point} sendList dual channel =
            match planes with
            | Nil              -> ic
            | Cons(plane,rest) ->
                let outrv = newRendezvous[{point} sendList] () in
                  threadFork (\_: unit.
                    clipper plane ic (request outrv));
                  connect rest (accept outrv) in
  \_: unit.
    let rv           = newRendezvous[main_prot] () in
    let _            = threadFork (\_: unit. parser (request rv)) in
    let (planes, ic) = get_planes Nil[{plane}] (accept rv) in
    let ic           = connect planes ic in
      printer ic

in
  main ()
