(* Demonstrates (affine) abstract types.  Correct. *)

(*
    This program is like ex25-array.aff, except that the main
    algorithm is written in C, which means that it uses contract
    checks on the array capabilities rather than static checks.
*)

#load "libarray-A.aff"

let[A] putA['a,'t,'c] (a: ('a, 't) array) (c: ('t, 'c) readcap) =
  putStr "[";
  let (_, c) =
    foldA (fun (x: 'a) (comma: bool) ->
             (if comma then putStr "," else ());
             putStr (string_of x);
             true)
          false a c in
  putStrLn "]";
  c

type[C] ('a, 't) array   = {({'a}, {'t}) array}
type[C] ('t, 'c) readcap = {({'t}, {'c}) readcap}
type[C] 't writecap      = {({'t}) writecap}

let[C] sumA ['t,'c] (a: (float, 't) array) (c: ('t, 'c) readcap) =
  foldA (+.) 0.0 a c

let[C] meanA ['t, 'c] (a: (float, 't) array) (c: ('t, 'c) readcap) =
  let (total, c) = sumA a c in
    (total /. float_of_int (sizeA a), c)

let[C] stdDevA ['t, 'c] (a: (float, 't) array) (c: ('t, 'c) readcap) =
  let (mean, c) = meanA a c in
  let (num, c)  = foldA
                    (fun (x: float) (acc: float) ->
                       acc +. (x -. mean) ** 2.0)
                    0.0 a c in
    (sqrt (num /. float_of_int (sizeA a)), c)

let[C] skewness ['t, 'c] (a: (float, 't) array) (c: ('t, 'c) readcap) =
  let n         = float_of_int (sizeA a) in
  let (m, c)    = meanA a c in
  let (s, c)    = stdDevA a c in
  let (devs, c) = foldA
                    (fun (x: float) (acc: float) ->
                       (x -. m) ** 3.0 +. acc)
                    0.0 a c in
    (devs /. ((n -. 1.0) *. s ** 3.0), c)

type[C] transformation = T of string * (float -> float)

let[C] reduceSkewness ['t]
                       (ts: transformation list)
                       (a: (float, 't) array)
                       (c0: 't writecap) =
  let rec replace (i: int)
                  (T(_, ft) as t: transformation)
                  (c: 't writecap)
                  : 't writecap =
    if i < sizeA a
      then let (x, c) = atA a i c in
           let c      = updateA a i (ft x) c in
             replace (i + 1) t c
      else c in
  let rec find ['c] (ix: int)
                    (ts: transformation list)
                    (c: ('t, 'c) readcap)
                    : float * transformation * ('t, 'c) readcap =
    match ts with
    | Nil -> let (sk, c) = skewness a c in
               (sk, T("identity", fun f: float -> f), c)
    | Cons(T(_, ft) as t, ts)
          -> let ((sk1, t1), (sk2, t2), c) =
               par
                 (fun 'c (c: ('t, 'c) readcap) -> find['c] (ix + 1) ts c)
                 (fun 'c (c: ('t, 'c) readcap) ->
                   mapA ft a c
                     (fun 's (b: (float, 's) array) (d: 's writecap)
                             (c: ('t, 'c) readcap) ->
                       let (sk, d) = skewness b d in
                         (sk, t, c)))
                 c
              in if absf sk2 <. absf sk1
                   then (sk2, t2, c)
                   else (sk1, t1, c) in
  let (sk, t, c) = find 0 ts c0 in
    (sk, t, replace 0 t c)

let[C] withNewDistribution['<r]
         (n: int) (T(_, gen): transformation)
         (k: all 't. (float, 't) array -> 't writecap -> '<r) : '<r =
  withNewA n (fun 't (a: (float, 't) array) (c: 't writecap) ->
    let rec loop (i: int) (c: 't writecap): 't writecap =
      if i < n
        then loop (i + 1) (updateA a i (gen (float_of_int (i + 1))) c)
        else c in
      k a (loop 0 c))

let[C] (^:) 'a (t: 'a) (ts: 'a list) = Cons(t, ts)

let[C] functions (n: int) =
  T("1",         fun (ix: float) -> 1.0) ^:
  T("x",         fun (ix: float) -> ix) ^:
  T("x^2",       flip ( ** ) 2.0) ^:
  T("sqrt x",    sqrt) ^:
  T("x^5",       flip ( ** ) 5.0) ^:
  T("x^1/5",     flip ( ** ) 0.2) ^:
  T("e^x",       ( ** ) 2.718) ^:
  T("log x",     log) ^:
  T("1/x",       (/.) 1.0) ^:
  T("-x",        (-.) (float_of_int n)) ^:
  Nil

let[C] testCase (n: int) (T(name, _) as t: transformation) =
  withNewDistribution n t
    (fun 't (a: (float, 't) array) (c: 't writecap) ->
      let (sk0, c)       = skewness a c in
      let (sk, T(name', _), c) = reduceSkewness (functions n) a c in
      putStrLn ("Distribution:      " ^ name);
      putStrLn ("Original skewness: " ^ string_of sk0);
      putStrLn ("Improved skewness: " ^ string_of sk);
      putStrLn ("Winning function:  " ^ name');
      putStrLn "")

let[C] tests (n: int) =
  foldlC (fun (t: transformation) () -> testCase n t)
         () (functions n)

in
  tests 30
