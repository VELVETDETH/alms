(* A semi-bad example with threads. (Possible contract error!)
   This is like the previous example (threads4.aff), but it allows
   wrapped (opaque) thread values themselves into C-world, rather
   than just functions.
*)

let[A] printer : unit -> unit =
  let rec loop (_ : unit) : unit =
    threadDelay 100000;
    putStr "x";
    flush ();
    loop ()
  in loop

let[A] start : unit -> thread =
  \_: unit. threadFork printer

let[A] stop : thread -> unit = threadKill

let[A] after : int -> (unit -o unit) -> unit =
  \delay: int.
    \stop: unit -o unit.
      threadFork (\_:unit . threadDelay delay; stop ());
      ()

(* {thread} is an "opaque" type *)
let[C] main : {thread} -> unit =
  \id: {thread}.
    after 4000000 (\_:unit. stop id);
    getLine ();
    stop id   (* second stop -- maybe contract error. *)

in
  putStrLn "Press <ENTER> to exit.";
  main (start ())

