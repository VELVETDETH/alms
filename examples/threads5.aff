(* A semi-bad example with threads. (Possible contract error!)
   This is like the previous example (threads4.aff), but it allows
   wrapped (opaque) thread values themselves into C-world, rather
   than just functions.
*)

#load "libthread-A.aff"

type[A] thread = AThread.thread

let[A] printer : unit -> unit =
  let rec loop (_ : unit) : unit =
    AThread.delay 100000;
    putStr "x";
    flush ();
    loop ()
  in loop

let[A] start : unit -> thread =
  fun _: unit -> AThread.fork printer

let[A] stop : thread -> unit = AThread.kill

let[A] after : int -> (unit -o unit) -> unit =
  fun delay: int ->
    fun stop: (unit -o unit) ->
      AThread.fork (fun _:unit  -> AThread.delay delay; stop ());
      ()

(* {thread} is an "opaque" type *)
let[C] main : {thread} -> unit =
  fun id: {thread} ->
    after 4000000 (fun _:unit -> stop id);
    getLine ();
    stop id   (* second stop -- maybe contract error. *)

in
  putStrLn "Press <ENTER> to exit.";
  main (start ())

