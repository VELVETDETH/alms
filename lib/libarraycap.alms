(*
  An affine array library.
*)

#load "libarray"

module type AARRAY_PRIM = sig
  type ('a, 't) array
  type `a / `b
  type 1
  type 2
  type ('t, 'c) readcap qualifier A
  type 't writecap = ('t, 1) readcap

  val new    : all 'a. int -> ex 't. ('a, 't) array * 't writecap
  val split  : all 't 'c. ('t, 'c) readcap ->
                 ('t, 'c/2) readcap * ('t, 'c/2) readcap
  val join   : all 't 'c.  ('t, 'c/2) readcap * ('t, 'c/2) readcap ->
                 ('t, 'c) readcap
  val at     : all 'a 't 'c. ('a, 't) array -> int -> ('t, 'c) readcap ->
                 'a * ('t, 'c) readcap
  val update : all 'a 't. ('a, 't) array -> int -> 'a ->
                 't writecap -> 't writecap
  val size   : all 'a 't. ('a, 't) array -> int
end

module AArray : sig
  include AARRAY_PRIM

  val par    : all 't 'c `r1 `r2.
                 (all 'd. ('t, 'd) readcap -> `r1 * ('t, 'd) readcap) ->
                 (all 'd. ('t, 'd) readcap -> `r2 * ('t, 'd) readcap) ->
                 ('t, 'c) readcap ->
                 `r1 * `r2 * ('t, 'c) readcap
  val fold   : all 'a 't 'c `r.
                 ('a -> `r -> `r) -> `r -> ('a, 't) array -[r]>
                 ('t, 'c) readcap -[r]>
                 `r * ('t, 'c) readcap
  val map    : all 'a 't 'c 'b.
                 ('a -> 'b) -> ('a, 't) array -> ('t, 'c) readcap ->
                 (ex 's. ('b, 's) array * 's writecap) * ('t, 'c) readcap
  val putArray
             : all 'a 't 'c. ('a, 't) array -> ('t, 'c) readcap ->
                 ('t, 'c) readcap
end = struct
  module A = Array

  open struct
    type ('a, 't) array   = 'a A.array
    type `a / `b
    type 1
    type 2
    type ('t, 'c) readcap = unit
    type 't writecap = ('t, 1) readcap

    let new['a] (size: int) =
      Pack[ex 't. ('a, 't) array * unit]
          (unit, A.newArray['a] size, ())

    let split['t,'c] () = ((), ())

    let join['t,'c] (_: unit * unit) = ()

    let at['a,'t,'c] (arr: ('a, 't) array) (ix: int) () =
      (A.at arr ix, ())

    let update['a,'t] (arr: ('a, 't) array) (ix: int) (new: 'a) () =
      A.update arr ix new

    let size['a,'t] (arr: ('a, 't) array) =
      A.size arr
  end : AARRAY_PRIM

  let par ['t,'c,`r1,`r2]
          (left:  all 'd. ('t, 'd) readcap -> `r1 * ('t, 'd) readcap)
          (right: all 'd. ('t, 'd) readcap -> `r2 * ('t, 'd) readcap)
          (c: ('t, 'c) readcap)
          : `r1 * `r2 * ('t, 'c) readcap =
    let (c1, c2) = split c in
    let future   = Future.new (fun () -> left c1) in
    let (r2, c2) = right c2 in
    let (r1, c1) = Future.get future in
      (r1, r2, join (c1, c2))

  let fold ['a,'t,'c,`r]
           (f: 'a -> `r -> `r) (z: `r)
           (a: ('a, 't) array) (c: ('t, 'c) readcap) =
    let rec loop (i: int) (z: `r)| (c: ('t, 'c) readcap)
                 : `r * ('t, 'c) readcap =
      if i < size a
        then let (elt, c) = at a i c in
               loop (i + 1) (f elt z) c
        else (z, c)
     in loop 0 z c

  let map ['a,'t,'c,'b]
          (f: 'a -> 'b)
          (a: ('a, 't) array) (c: ('t, 'c) readcap)
          : (ex 's. ('b, 's) array * 's writecap) * ('t, 'c) readcap =
    let Pack('s, (b, d)) = new['b] (size a) in
    let ((_, d), c)      = fold (fun (x: 'a) (i: int, d: 's writecap) ->
                                    (i + 1, update b i (f x) d))
                                 (0, d) a c in
      (Pack[ex 't. ('b, 't) array * 't writecap]('s, (b, d)), c)

  let putArray['a,'t,'c] (a: ('a, 't) array) (c: ('t, 'c) readcap) =
    putStr "[";
    let (_, c) =
      fold (fun (x: 'a) (comma: bool) ->
              (if comma then putStr "," else ());
              putStr (string_of x);
              true)
           false a c in
    putStrLn "]";
    c
end
