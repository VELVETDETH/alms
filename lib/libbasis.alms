open Exn

let failwith (msg: string) =
  raise (Failure msg)

let not (b: bool) = if b then false else true
let (!=)['a] (x: 'a) (y: 'a) = not (x == y)

let flip['a,'b,'c] (f: 'a -> 'b -> 'c) (y: 'b) (x: 'a) = f x y

let (<) (x: int) (y: int) = not (y <= x)
let (>) = flip (<)
let (>=) = flip (<=)
let (>.) = flip (<.)
let (>=.) = flip (<=.)

let null = fun 'a (x : 'a list) ->
  match x with
  | Nil -> true
  | _   -> false
let anull = fun '<a (xs : '<a list) ->
  match xs with
  | Nil          -> (Nil['<a], true)
  | Cons(x, xs') -> (Cons(x, xs'), false)
let hd = fun 'a (xs : 'a list) ->
  let Cons(x, _) = xs in x
let tl = fun 'a (xs : 'a list) ->
  let Cons(_, xs') = xs in xs'
let foldr =
  let rec foldr '<a '<b (f : '<a -> '<b -o '<b)
                        (z : '<b) |(xs : '<a list) : '<b =
        match xs with
        | Nil -> z
        | Cons(x,xs) -> f x (foldr f z xs)
   in foldr
let foldl =
  let rec foldl '<a '<b (f : '<a -> '<b -o '<b)
                        (z : '<b) |(xs : '<a list) : '<b =
        match xs with
        | Nil -> z
        | Cons(x,xs) -> foldl f (f x z) xs
   in foldl
let revApp['<a] (xs : '<a list) (ys : '<a list) =
  let cons (x : '<a) (acc : '<a list) = Cons (x, acc) in
    foldl cons ys xs
let rev['<a] (xs : '<a list) = revApp xs Nil
let append['<a] (xs : '<a list) = revApp (rev xs)
let length['<a] (xs : '<a list) =
  foldr (fun (x : '<a) -> (+) 1) 0 xs
let lengthA['<a] (xs : '<a list) =
  let count (x : '<a) (n : int, xs' : '<a list) =
       (1 + n, Cons (x, xs')) in
    foldr count (0, Nil['<a]) xs

let fst['<a,'<b] (x: '<a, _: '<b) = x
let snd['<a,'<b] (_: '<a, y: '<b) = y

let (=>!) ['<a] (x: '<a) ['<b] (y: '<b) = (y, x)

module Contract = struct
  type party = string
  type '<a contract = party * party -> '<a -> '<a

  let flat['a] (pred: 'a -> bool) =
    fun (neg: party, pos: party) (a: 'a) ->
      if pred a
        then a
        else Exn.raiseBlame pos "violated contract"

  let flatA['<a] (pred: '<a -> bool * '<a) =
    fun (neg: party, pos: party) (a: '<a) ->
      match pred a with
      | (true, a)  -> a
      | (false, _) -> Exn.raiseBlame pos "violated contract"

  let any['<a] (_: party, _: party) (a: '<a) = a

  let func['<a, '<b] (dom: '<a contract, cod: '<b contract) =
    fun (neg: party, pos: party) (f: '<a -> '<b) ->
      fun (a: '<a) -> cod (neg, pos) (f (dom (pos, neg) a))

  let funcA['<a, '<b] (dom: '<a contract, cod: '<b contract) =
    fun (neg: party, pos: party) (f: '<a -o '<b) ->
      fun (a: '<a) -> cod (neg, pos) (f (dom (pos, neg) a))

  let affunc['<a, '<b] (dom: '<a contract, cod: '<b contract) =
    fun (neg: party, pos: party) (f: '<a -o '<b) ->
      let rf = ref (Some f) in
        fun (a: '<a) ->
          match rf <- None['<a -o '<b] with
          | Some f -> cod (neg, pos) (f (dom (pos, neg) a))
          | None   -> Exn.raiseBlame neg "reused one-shot function"
end

module INTERNALS = struct
  module Contract = Contract
end

