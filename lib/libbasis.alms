module INTERNALS = struct
  module PrimTypes = struct
    type unit    = type unit
    type variant = type variant
    type record  = type record
    type rowend  = type rowend
    type rowdots = type rowdots
    type U       = type U
    type A       = type A
    type bool    = type bool
  end

  module Exn = struct
    open Prim.Exn

    exception Failure of string
    exception IOError of string 
    exception Blame of string * string
    exception PatternMatch of string * string list
    exception UninitializedLetRec of string

    let failwith (msg: string) =
      raise (Failure msg)

    let tryfun (thunk: unit -o `a) : exn + `a =
      match tryfun_string thunk with
      | Right a        -> Right a
      | Left (Left e)  -> Left e
      | Left (Right s) -> Left (IOError s)

    let raiseBlame (who: string) (what: string) =
      raise (Blame (who, what))
  end

  local
    module INTERNALS = struct
      module Exn       = Exn
      module PrimTypes = PrimTypes
    end
  with
    module Contract = struct
      type party = string
      type (`a, `b) coercion = party * party -> `a -> `b
      type `a contract = party * party -> `a -> `a

      (* Flat contracts for unlimited values. *)
      let flat (pred: 'a -> bool) : 'a contract =
        fun (neg: party, pos: party) (a: 'a) ->
          if pred a
            then a
            else Exn.raiseBlame pos "violated contract"

      (* Flat contracts for affine values. *)
      let flatA (pred: `a -> bool * `a) : `a contract =
        fun (neg: party, pos: party) (a: `a) ->
          match pred a with
          | (true, a)  -> a
          | (false, _) -> Exn.raiseBlame pos "violated contract"

      (* The identity contract. *)
      let any : `a contract =
        fun (_: party, _: party) (a: `a) -> a

      (* Add domain and codomain contracts to a function. *)
      let func
               (dom: (`a1, `a2) coercion)
               (cod: (`b1, `b2) coercion)
              : (`a2 -[`q]> `b1, `a1 -[`q]> `b2) coercion =
        fun (neg: party, pos: party) (f: `a2 -[`q]> `b1) ->
          fun (a: `a1) -> cod (neg, pos) (f (dom (pos, neg) a))

      (* Coerce an affine function to an unlimited function, and
         check dynamically that it's applied only once. *)
      let affunc (dom: (`a1, `a2) coercion)
                 (cod: (`b1, `b2) coercion)
                : (`a2 -o `b1, `a1 -> `b2) coercion =
        fun (neg: party, pos: party) (f: `a2 -o `b1) ->
          let rf = ref (Some f) in
            fun (a: `a1) ->
              match rf <- None with
              | Some f -> cod (neg, pos) (f (dom (pos, neg) a))
              | None   -> Exn.raiseBlame neg "reused one-shot function"

      (* Check that an ostensibly unlimited function is actually
         unlimited. *)
      let unfunc (dom: (`a1, `a2) coercion)
                 (cod: (`b1, `b2) coercion)
                : (`a2 -> `b1, `a1 -> `b2) coercion =
        fun (neg: party, pos: party) (f: `a2 -> `b1) ->
          fun (x: `a1) ->
            let x' = dom (pos, neg) x in
            let y  = try f x' with
                     | Exn.Blame(p, "reused one-shot function")
                         -> Exn.raiseBlame pos "raised blame" in 
            cod (neg, pos) y
    end
  end
end

let not (b: bool) = if b then false else true
let (!=) (x: 'a) (y: 'a) = not (x == y)

let flip (f: 'a -> 'b -> 'c) (y: 'b) (x: 'a) = f x y

let (<) (x: int) (y: int) = not (y <= x)
let (>) = flip (<)
let (>=) = flip (<=)
let (>.) = flip (<.)
let (>=.) = flip (<=.)

type `a × `b = `a * `b
(* These have too-tight precedences *)
let (≠)  = (!=)
let (≤)  = (<=)
let (≥)  = (>=)
let (≤.) = (<=.)
let (≥.) = (>=.)

let null = fun (x : 'a list) ->
  match x with
  | Nil -> true
  | _   -> false
let anull = fun (xs : `a list) ->
  match xs with
  | Nil          -> (Nil, true)
  | Cons(x, xs') -> (Cons(x, xs'), false)
let hd = fun (xs : 'a list) ->
  let Cons(x, _) = xs in x
let tl = fun (xs : 'a list) ->
  let Cons(_, xs') = xs in xs'
let rec foldr f z xs =
  match xs with
  | Nil -> z
  | Cons(x,xs) -> f x (foldr f z xs)
let rec foldl f z xs =
  match xs with
  | Nil -> z
  | Cons(x,xs) -> foldl f (f x z) xs
let map f xs =
  foldr (λ x xs' -> Cons (f x, xs')) Nil xs
let filter f xs =
  foldr (λ x xs' -> if f x then Cons(x, xs') else xs')
        Nil
let mapFilterA (f: `a -> `b option) (xs: `a list) =
      foldr (fun (x: `a) (xs': `b list) ->
               match f x with
               | Some y -> Cons(y, xs')
               | None   -> xs')
            Nil
            xs
let revApp (xs : `c list) (ys : `c list) =
  let cons (x : `c) (acc : `c list) = Cons (x, acc) in
    foldl cons ys xs
let rev (xs : `b list) = revApp xs Nil
let append (xs : `a list) = revApp (rev xs)
let length (xs : `a list) =
  foldr (fun (x : `a) -> (+) 1) 0 xs
let lengthA (xs : `a list) =
  let count (x : `a) (n : int, xs' : `a list) =
       (1 + n, Cons (x, xs')) in
    foldr count (0, Nil) xs

let fst (x: `a, _: `b) = x
let snd (_: `a, y: `b) = y

let (=>!)  (x: `a)  (y: `b) = (y, x)
let (⇒) = (=>!)

let (←) = (<-)
let (⇐) = (<-!)

module Exn      = INTERNALS.Exn
module Contract = INTERNALS.Contract
open Exn
