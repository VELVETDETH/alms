(*
    A typestate sockets library

    This is a bit more involved than the example in the paper,
    because we have error cases.  We deal with this by raising
    an exception which contains a witness that allows recovering
    the capability if presented with the corresponding socket.
*)

#load "libsocket"

module type SOCKET_CAP = sig
  (* The representation of a socket *)
  type 'a socket

  (* Socket capabilities and the socket states *)
  type 'a @ 'c : A
  type raw
  type named
  type listening
  type ready

  (* Socket operations *)
  val socket  : unit → ∃ 'a. 'a socket * 'a@raw
  val bind    : 'a socket → int → 'a@raw → 'a@named

  val connect : 'a socket → string → string →
                  'a@raw + 'a@named → 'a@ready
  val listen  : 'a socket → 'a@named → 'a@listening
  val accept  : 'a socket → 'a@listening →
                  (∃ 'b. 'b socket * 'b@ready) * 'a@listening
  val send    : 'a socket → string → 'a@ready → 'a@ready
  val recv    : 'a socket → int → 'a@ready → string * 'a@ready
  val close   :  'a socket → 'a@'c → unit

  val reassociate : 'a socket → 'b socket → 'a@'c → 'a@'c + 'b@'c

  (* Operations for catching the error state associated with a given
     socket. *)
  val catchRaw       : (unit -A> `r) → 'a socket × ('a@raw -A> `r)       → `r
  val catchNamed     : (unit -A> `r) → 'a socket × ('a@named -A> `r)     → `r
  val catchListening : (unit -A> `r) → 'a socket × ('a@listening -A> `r) → `r
  val catchReady     : (unit -A> `r) → 'a socket × ('a@ready -A> `r)     → `r

  type 'a dynamicCap = Raw of 'a@raw
                     | Named of 'a@named
                     | Listening of 'a@listening
                     | Ready of 'a@ready

  exception Socket of (∃'a. 'a socket * 'a dynamicCap) option * string
end

module SocketCap : SOCKET_CAP = struct
  module S = Socket

  type 'a socket  = S.socket
  type 'a @ 'c = unit
  type raw
  type named
  type listening
  type ready

  type 'a dynamicCap = Raw of 'a@raw
                     | Named of 'a@named
                     | Listening of 'a@listening
                     | Ready of 'a@ready

  exception Socket of (∃'a. 'a socket * 'a dynamicCap) option * string

  let error (sockcap : ∃'a. 'a socket * 'a dynamicCap) msg =
    raise (Socket (Some sockcap, msg))

  let socket _ : ∃ 'a. 'a socket × 'a@raw =
    try (S.socket (), ())
    with IOError msg → raise (Socket (None, msg))

  let bind sock port _ =
    try S.bind sock port
    with IOError msg → error (sock, Raw ()) msg

  let connect sock host port cap =
    try S.connect sock host port
    with
      IOError msg → match cap with
        | Left _  → error (sock, Raw ()) msg
        | Right _ → error (sock, Named ()) msg

  let listen sock _ =
    try S.listen sock
    with IOError msg → error (sock, Named ()) msg

  let accept sock _ =
    try ((S.accept sock, ()) : ∃ 'a. 'a socket × 'a@ready, ())
    with IOError msg → error (sock, Listening ()) msg

  let send sock data _ =
    try S.send sock data; ()
    with IOError msg → error (sock, Ready ()) msg

  let recv sock len _ =
    try (S.recv sock len, ())
    with IOError msg → error (sock, Ready ()) msg

  let close sock _ =
    try S.close sock
    with IOError msg → raise (Socket (None, msg))

  let reassociate sock sock' _ =
    if sock == sock'
      then Right ()
      else Left ()

  let catchBy body pred (sock, handler) =
    try body () with
    | Socket ((Some (sock', dyncap), msg) as se) →
        match (pred dyncap, reassociate sock sock' ()) with
        | (true, Right cap) → handler cap
        | _ → raise (Socket se)

  let catchRaw body =
    catchBy body (function Raw _ → true | _ → false)
  let catchNamed body =
    catchBy body (function Named _ → true | _ → false)
  let catchListening body =
    catchBy body (function Listening _ → true | _ → false)
  let catchReady body =
    catchBy body (function Ready _ → true | _ → false)
end

module SocketCap2 : SOCKET_CAP = struct
  open SocketCap
  let catchBy body
              (prj : ∀'a. 'a dynamicCap →
                          'a dynamicCap + ('a@'c -A> 'a dynamicCap) × 'a@'c)
              (sock', handler) =
    try body () with
    | Socket (Some (sock, dyncap), msg) →
        match prj dyncap with
        | Left dyncap
          → raise (Socket (Some (sock, dyncap), msg))
        | Right (uncap, cap)
          → match reassociate sock sock' cap with
            | Left cap   → raise (Socket (Some (sock, uncap cap), msg))
            | Right cap' → handler cap'

  let catchRaw body =
    catchBy body (function Raw cap → Right (Raw, cap)
                         | dyncap → Left dyncap)
  let catchNamed body =
    catchBy body (function Named cap → Right (Named, cap)
                         | dyncap → Left dyncap)
  let catchListening body =
    catchBy body (function Listening cap → Right (Listening, cap)
                         | dyncap → Left dyncap)
  let catchReady body =
    catchBy body (function Ready cap → Right (Ready, cap)
                         | dyncap → Left dyncap)
end
