Alms has been instrumented to print out types using various implicit
arrow labeling rules.  It can be made to print out all syntactic types
that have been kind checked (mode A) or to print out the type of every
top-level let-bound expression (mode B).

We are trying 6 rules:

    0: Print all annotations explicitly.

    1: Use unannotated arrows for -U>, so implicit = unlimited.

    2: Accumulate the qualifiers of curried arguments and use
       the accumulated qualifier for implicit annotations.

    3: Like 2, but when we encounter an explicit annotation, that
       replaced the accumulated qualifier.

    4: Like 3, but we retain the accumulated qualifier when going under
       covariant type constructors to the left of an arrow.

    5: Like 4, but we retain the accumulated qualifier when going under
       any composition of type constructors whose net result is
       covariant.

To get the types of the built-in operations, we run Alms in mode A,
using the -b switch to prevent it from loading additional libraries. For
each rule set $i from 0 to 5, we have to recompile Alms to use that that
rule set, load it, and capture the results:

    make && < /dev/null ./alms -b 2> iadata/iadata$i.builtin

Then, to get the types of operations in the library, we run Alms in mode
B.  I'm actually running the entire test suite, to get as many types as
possible:

    make && make test 2> iadata/iadata$i.lib

For now, I'm combining both the builtin and lib data for each trial for
my analysis, because I have no reason to believe that should be treated
separately.

I've written a Haskell program, analyze.hs, that loads the trial data.
It removes duplicates from the trials, since some types may appear many
times.  (It might be valid not to remove duplicates, since we care about
types that are written repeatedly, but since these are libraries, very
few types are actually written repeatedly, and the effect of library
loading, which causes the same types to appear each time a library is
written, would dominate.)  To remove duplicates, we treat trial 0 (all
annotations explicit) as the reference trial, and for duplicate lines in
0, we remove the corresponding lines in the other trials. (As a sanity
check, it turns on that using any particular trial as the reference
produces the same result, which means that none of the rules obviously
results in information loss.)

We performed a pairwise comparison of the trial results. For the actual
corpus of types present here, rules 2, 3, 4, and 5 give exactly the same
results. Thus, it makes sense to compare only rules 0, 1, and 2

Each trial has 326 types, of which 309 are non-trivial (contain arrows).
These contain a total of 588 arrows, which means 590 potential
annotations.  Of the 309 arrow types, we have:

  Rule | ann. types | annotations
  -----+------------+------------
   0   |        309 |         588
   1   |         40 |          63
   2,3 |         18 |          21
   4,5 |         17 |          20

Of the 20-21 annotations required in rules 2-5, all but one of them are the
same in rule 1.  Rules 2-5 add one annotation, where an unannotated arrow by
rule 1 needs a U in the other rules:

Rule 1:
  (`a1, `a2) coercion -> (`b1, `b2) coercion ->
    party * party -> (`a2 -A> `b1) -> `a1 -> `b2

Rule 2:
  (`a1, `a2) coercion -> (`b1, `b2) coercion ->
    party * party -> (`a2 -A> `b1) -> `a1 -U> `b2


We can categorize all the annotations the remain in rules 2-5:

  -A> in negative position indicating functions that apply their
  arguments but once (15 types, 17 annotations)

all `a. (unit -A> `a) -> `a Future.future
all `a. (`a Future.future -A> unit) -> `a Future.cofuture
all `a. (unit -A> `a) -> exn +  string +  `a
all `a. (unit -A> `a) -> exn +  `a
all `a `b. (`a -> `b -A> `b) -> `b -> `a list -> `b
all `a `b. (`a -A> `b) -> `a -> `b
(int -A> int) -> int -> int
all 'a 'b. ('a -A> 'b) -> 'a -> 'b
all 't 'c `a. ('t, 'c) AArray.readcap -> (('t, 'c) ureadcap -A> `a) -> `a *  ('t, 'c) AArray.readcap
all 't 'c `r. (('t, 'c) AArray.readcap -A> `r *  ('t, 'c) AArray.readcap) -> ('t, 'c) ureadcap -> `r
(unit -A> unit) -> Thread.thread
all `a 'ta `b 'tb. ('ta, `a) cap *  'ta tr -> ('tb, `b) cap *  'tb tr -> (('ta, `a) cap -A> unit) -> ('tb, `b) cap *  ('tb, `a) guarded
all `a 't `b `r. ('t, `a) cap *  ('t, `b) guarded -> (all 's. ('s, `b) cap *  's tr -A> ('s, `b) cap *  `r) -> ('t, `a) cap *  `r
all 't `a. ASocket.rep -> (unit -A> `a) -> (unit -A> `a) -> `a
all `a. ASocket.rep -> (unit -A> `a) -> (unit -A> `a) -> `a

  weird contract thing (1 type, 2 annotations):

all `a1 `a2. (`a1, `a2) INTERNALS.Contract.coercion -> all `b1 `b2. (`b1, `b2) INTERNALS.Contract.coercion -> INTERNALS.Contract.party *  INTERNALS.Contract.party -> (`a2 -A> `b1) -> `a1 -U> `b2

  relating domain and range (rules 2-3: 2 types, 2 annotations; /rules
  4-5: 1 type, 1 annotations):

all `q `a1 `a2. (`a1, `a2) INTERNALS.Contract.coercion -> all `b1 `b2. (`b1, `b2) INTERNALS.Contract.coercion -> INTERNALS.Contract.party *  INTERNALS.Contract.party -> (`a2 -q> `b1) -> `a1 -> `b2
all `a 't. ('t, `a) region -> 't ptr -> ex 't1. ('t1, `a) region1 *  't1 ptr *  (('t1, `a) region1 -A> ('t, `a) region)


